diff -urN dazuko-2.2.0.orig/configure dazuko-2.2.0/configure
--- dazuko-2.2.0.orig/configure	2006-01-20 21:28:08.000000000 +0100
+++ dazuko-2.2.0/configure	2006-03-16 09:57:43.000000000 +0100
@@ -47,6 +47,7 @@
 	echo "override auto-detection values"
 	echo "  --kernelsrcdir=DIR   kernel source files in DIR (Linux only)"
 	echo "  --devicemajor=MAJ    use MAJ for device major number"
+	echo "  --redirfs-path=PATH  PATH to the RedirFS source code (RedirFS interface redirfs.h)"
 	echo "  --system=SYS         configure for system SYS (linux22,linux24,linux26,"
 	echo "                                                freebsd4,freebsd5"
 	echo "                                                freebsd6,dummyos)"
@@ -66,6 +67,7 @@
 	echo "  --disable-chroot-support        disable resolving chroot'd filenames"
 	echo "  --disable-local-dpath           disable local __d_path() (Linux 2.6 only)"
 	echo "  --disable-compat1               disable 1.x compatibility (IO/Linux only)"
+	echo "  --enable-redirfs [EXPERIMENTAL] use RedirFS Framework (for now Linux 2.6 only)"
 	echo "  --enable-debug                  print extra debug information"
 	echo ""
 	echo "optional packages"
@@ -357,33 +359,36 @@
 
 do_linux26()
 {
-	echo -n "checking if security module support is enabled... "
-	if [ $CONFIG_SECURITY -eq 0 ]
+	if [ ${REDIRFS} -eq 0 ]
 	then
-		echo "no"
-		echo "error: security module support must be enabled in your kernel"
-		exit 1
-	else
-		echo "yes"
-	fi
+		echo -n "checking if security module support is enabled... "
+		if [ $CONFIG_SECURITY -eq 0 ]
+		then
+			echo "no"
+			echo "error: security module support must be enabled in your kernel"
+			exit 1
+		else
+			echo "yes"
+		fi
 
-	echo -n "verifying capabilities are not built-in... "
-	if [ $CONFIG_SECURITY_CAPABILITIES -ne 0 ]
-	then
-		echo "built-in :("
-		echo "error: capabilities are built-in to the kernel:"
-		echo "       you will need to recompile a kernel with capabilities"
-		echo "       as a kernel module"
-		exit 1
-	else
-		echo "ok"
-	fi
+		echo -n "verifying capabilities are not built-in... "
+		if [ $CONFIG_SECURITY_CAPABILITIES -ne 0 ]
+		then
+			echo "built-in :("
+			echo "error: capabilities are built-in to the kernel:"
+			echo "       you will need to recompile a kernel with capabilities"
+			echo "       as a kernel module"
+			exit 1
+		else
+			echo "ok"
+		fi
 
-	if [ $CONFIG_SECURITY_CAPABILITIES_MODULE -eq 0 ]
-	then
-		NO_CAPABILITIES=1
-	fi
+		if [ $CONFIG_SECURITY_CAPABILITIES_MODULE -eq 0 ]
+		then
+			NO_CAPABILITIES=1
+		fi
 
+	fi
 	echo -n "locating LSM API header... "
 
 	SRC_PATH_END="/include/linux/security.h"
@@ -398,6 +403,7 @@
 		echo "ok"
 	fi
 
+	
 	echo -n "identifying LSM API... "
 	if [ ! -x "linux_lsm_conf" ]
 	then
@@ -486,22 +492,41 @@
 		echo "ok (class_simple)"
 	fi
 
-	if [ $ON_CLOSE -ne 0 ]
+	echo "configure: creating Makefile"
+
+	echo "EXTRA_CFLAGS += -Wall -DLINUX26_SUPPORT" > Makefile
+
+	if [ ${ON_CLOSE} -ne 0 ]
 	then
-		echo "disabling ON_CLOSE events (not available for Linux 2.6)"
-		ON_CLOSE=0
+		if [ ${REDIRFS} -eq 0 ]
+		then
+			echo "disabling ON_CLOSE events (not available for Linux 2.6)"
+			ON_CLOSE=0
+		else
+			echo "EXTRA_CFLAGS += -DON_CLOSE_SUPPORT" >> Makefile
+		fi
 	fi
 
 	if [ ${ON_UNLINK} -ne 0 ]
 	then
-		echo "disabling ON_UNLINK events (not available for Linux 2.6)"
-		ON_UNLINK=0
+		if [ ${REDIRFS} -eq 0 ]
+		then
+			echo "disabling ON_UNLINK events (not available for Linux 2.6)"
+			ON_UNLINK=0
+		else
+			echo "EXTRA_CFLAGS += -DON_UNLINK_SUPPORT" >> Makefile
+		fi
 	fi
 
 	if [ ${ON_RMDIR} -ne 0 ]
 	then
-		echo "disabling ON_RMDIR events (not available for Linux 2.6)"
-		ON_RMDIR=0
+		if [ ${REDIRFS} -eq 0 ]
+		then
+			echo "disabling ON_RMDIR events (not available for Linux 2.6)"
+			ON_RMDIR=0
+		else
+			echo "EXTRA_CFLAGS += -DON_RMDIR_SUPPORT" >> Makefile
+		fi
 	fi
 
 	if [ ${ON_CLOSE_MODIFIED} -ne 0 ]
@@ -512,11 +537,20 @@
 
 	LINUX26_OBJS="dazuko_linux26.o"
 
-	echo "configure: creating Makefile"
-
-	echo "EXTRA_CFLAGS += -Wall -DLINUX26_SUPPORT" > Makefile
+	if [ ${REDIRFS} -eq 1 ]
+	then
+		if [ -z ${REDIRFS_PATH} ]
+		then
+			echo "error: if you want to use Dazuko with the RedirFS Framework"
+			echo "       you have to specify path to the RedirFS source" 
+			echo "       code with the --redirfs-path option"
+			exit 1
+		fi
+		echo "EXTRA_CFLAGS += -I${REDIRFS_PATH}" >> Makefile
+		echo "EXTRA_CFLAGS += -DDAZUKO_REDIRFS" >> Makefile
+	fi
 
-	if [ ${LSM_STACKING} -eq 1 ]
+	if [ ${LSM_STACKING} -eq 1 -a ${REDIRFS} -eq 0 ]
 	then
 		LINUX26_OBJS="dazuko_linux26_lsm.o ${LINUX26_OBJS}"
 	else
@@ -563,6 +597,11 @@
 		echo "EXTRA_CFLAGS += -DDEVFS_SUPPORT" >> Makefile
 	fi
 
+	if [ ${ON_EXEC} -eq 1 ]
+	then
+		echo "EXTRA_CFLAGS += -DON_EXEC_SUPPORT" >> Makefile
+	fi
+
 	if [ ${ON_OPEN} -eq 1 ]
 	then
 		echo "EXTRA_CFLAGS += -DON_OPEN_SUPPORT" >> Makefile
@@ -1069,6 +1108,14 @@
 				echo "no"
 			fi
 
+			echo -n "redirfs support = "
+			if [ ${REDIRFS} -eq 1 ]
+			then
+				echo "yes [EXPERIMENTAL]"
+			else
+				echo "no"
+			fi
+
 			if echo $LINUX_VERSION | grep -q ^2\.6\.
 			then
 				echo -n "stacking support = "
@@ -1158,6 +1205,8 @@
 DEVFS=0
 RSBAC=0
 DEBUG=0
+REDIRFS=0
+REDIRFS_PATH=""
 WITH_MODULE=1
 FORCE_RSBAC=2
 WITH_LIBRARY=2
@@ -1222,6 +1271,12 @@
 		--enable-debug)
 			DEBUG=1
 			;;
+		--enable-redirfs)
+			REDIRFS=1
+			;;
+		--redirfs-path=*)
+			REDIRFS_PATH=`echo $option | sed -e s/^--redirfs-path=//`
+			;;
 		--enable-trusted)
 			TRUSTED=1
 			;;
@@ -1519,33 +1574,40 @@
 			. linux.config
 			rm -f linux.config
 
-			echo -n "checking if Linux is RSBAC patched... "
-
-			if [ $FORCE_RSBAC -ne 2 ]
-			then
-				CONFIG_RSBAC=$FORCE_RSBAC
-				echo -n "(forced) "
-			fi
-
-			if [ $CONFIG_RSBAC -ne 0 ]
-			then
-				echo "yes"
-				RSBAC=1
-
-				SYSTEM="rsbac"
-			else
-				echo "no"
-
-				echo -n "checking if devfs is enabled... "
-				if [ $CONFIG_DEVFS_FS -eq 0 ]
-				then
-					DEVFS=0
-					echo "no"
-				else
-					DEVFS=1
-					echo "yes"
-				fi
-			fi
+			if [ $REDIRFS -ne 0 ]
+  			then
+ 				echo -n "checking for redirfs.h... "
+ 				if [ -f ${REDIRFS_PATH}/redirfs.h ]
+  				then
+ 					echo "yes"
+  				else
+ 					echo "no"
+ 					echo "error: file ${REDIRFS_PATH}/redirfs.h not found"
+ 					echo "       please check the --redirfs-path option"
+ 					exit 1
+ 				fi
+ 			else
+ 				echo -n "checking if Linux is RSBAC patched... "
+ 				if [ $CONFIG_RSBAC -ne 0 ]
+ 				then
+  					echo "yes"
+ 					RSBAC=1
+ 
+ 					SYSTEM="rsbac"
+ 				else
+ 					echo "no"
+ 
+ 					echo -n "checking if devfs is enabled... "
+ 					if [ $CONFIG_DEVFS_FS -eq 0 ]
+ 					then
+ 						DEVFS=0
+ 						echo "no"
+ 					else
+ 						DEVFS=1
+ 						echo "yes"
+ 					fi
+  				fi
+  			fi
 
 			UNAME_R="$LINUX_VERSION"
 		fi
diff -urN dazuko-2.2.0.orig/dazuko_core.c dazuko-2.2.0/dazuko_core.c
--- dazuko-2.2.0.orig/dazuko_core.c	2006-02-18 22:16:36.000000000 +0100
+++ dazuko-2.2.0/dazuko_core.c	2006-03-15 17:57:04.000000000 +0100
@@ -35,6 +35,9 @@
 #include "dazuko_platform.h"
 #include "dazuko_core.h"
 #include "dazuko_version.h"
+#if defined(DAZUKO_REDIRFS)
+#include "redirfs.h"
+#endif
 
 /* inline code */
 #include "dazuko_call.h"
@@ -67,6 +70,10 @@
 #define	DAZUKO_BROKEN	5	/* invalid state (interrupt from ready,waiting) */
 
 
+#if defined(DAZUKO_REDIRFS)
+extern redirfs_filter dazukoflt;
+#endif
+
 struct path
 {
 	/* A node in a linked list of paths. Used
@@ -1589,10 +1596,28 @@
 
 		case ADD_INCLUDE_PATH:
 			error = dazuko_insert_path_fs(&(sl->incl_paths), &(sl->lock_lists), (char *)param, len);
+#if defined(DAZUKO_REDIRFS)
+			if (!error) {
+				error = redirfs_include_path(dazukoflt, param);
+				if (error) {
+					xp_print("dazuko: unable to include path `%s` for Dazuko Filter: %d\n", param, error);
+					return error;
+				}
+			}
+#endif
 			break;
 
 		case ADD_EXCLUDE_PATH:
 			error = dazuko_insert_path_fs(&(sl->excl_paths), &(sl->lock_lists), (char *)param, len);
+#if defined(DAZUKO_REDIRFS)
+			if (!error) {
+				error = redirfs_exclude_path(dazukoflt, param);
+				if (error) {
+					xp_print("dazuko: unable to exclude path `%s` for Dazuko Filter: %d\n", param, error);
+					return error;
+				}
+			}
+#endif
 			break;
 
 		case REMOVE_ALL_PATHS:
@@ -1929,7 +1954,7 @@
 	int			error;
 
 	i = dazuko_event2index(event);
-	if (i < 0 || i >= NUM_EVENTS)
+	if (i < 0 || i > NUM_EVENTS)
 	{
 		call_xp_print("dazuko: unknown event:%d, allowing access (possible bug)\n", event);
 		return 0;
diff -urN dazuko-2.2.0.orig/dazuko_linux26.c dazuko-2.2.0/dazuko_linux26.c
--- dazuko-2.2.0.orig/dazuko_linux26.c	2006-02-18 22:16:04.000000000 +0100
+++ dazuko-2.2.0/dazuko_linux26.c	2006-03-16 09:47:45.000000000 +0100
@@ -36,6 +36,9 @@
 #include <linux/suspend.h>
 #endif
 #include <asm/uaccess.h>
+#if defined(DAZUKO_REDIRFS)
+#include "redirfs.h"
+#endif
 
 
 #ifndef DAZUKO_DM
@@ -67,7 +70,7 @@
 static struct dentry    *orig_root = NULL;
 static int dev_major = -1;
 
-#ifndef DAZUKO_FIST
+#if !defined(DAZUKO_FIST) && !defined(DAZUKO_REDIRFS)
 #ifdef NO_STACKING_SUPPORT
 struct security_operations dazuko_security_ops;
 #else
@@ -86,6 +89,49 @@
 #endif
 #endif
 
+#if defined(DAZUKO_REDIRFS)
+/*
+ *  Global stuffs for the RedirFS Framework
+ */
+redirfs_filter dazukoflt;
+
+#if defined(ON_EXEC_SUPPORT)
+static enum redirfs_retv dazukoflt_pre_permission(redirfs_context context, struct redirfs_args_t *args);
+#endif
+#if defined(ON_OPEN_SUPPORT)
+static enum redirfs_retv dazukoflt_pre_open(redirfs_context context, struct redirfs_args_t *args);
+#endif
+#if defined(ON_CLOSE_SUPPORT) 
+static enum redirfs_retv dazukoflt_post_flush(redirfs_context context, struct redirfs_args_t *args);
+#endif
+#if defined(ON_UNLINK_SUPPORT)
+static enum redirfs_retv dazukoflt_pre_unlink(redirfs_context context, struct redirfs_args_t *args);
+#endif
+#if defined(ON_RMDIR_SUPPORT)
+static enum redirfs_retv dazukoflt_pre_rmdir(redirfs_context context, struct redirfs_args_t *args);
+#endif
+
+static struct redirfs_op_t dazukoflt_ops[] = {
+#if defined(ON_EXEC_SUPPORT)
+	{REDIRFS_I_REG, REDIRFS_IOP_PERMISSION, dazukoflt_pre_permission, NULL},
+#endif
+#if defined(ON_OPEN_SUPPORT)
+	{REDIRFS_F_REG, REDIRFS_FOP_OPEN, dazukoflt_pre_open, NULL},
+#endif
+#if defined(ON_CLOSE_SUPPORT) 
+	{REDIRFS_F_REG, REDIRFS_FOP_FLUSH, NULL, dazukoflt_post_flush},
+#endif
+#if defined(ON_UNLINK_SUPPORT)
+	{REDIRFS_I_DIR, REDIRFS_IOP_UNLINK, dazukoflt_pre_unlink, NULL},
+#endif
+#if defined(ON_RMDIR_SUPPORT)
+	{REDIRFS_I_DIR, REDIRFS_IOP_RMDIR, dazukoflt_pre_rmdir, NULL},
+#endif
+	REDIRFS_OP_END
+};
+#endif /* DAZUKO_REDIRFS */
+
+
 #ifdef NO_CAPABILITIES
 int lsm_capability_compare(struct security_operations *ops1, struct security_operations *ops2);
 #endif
@@ -939,9 +985,134 @@
 	return 0;
 }
 
+#if defined(DAZUKO_REDIRFS)
+static int redirfs_generic(int event, struct inode *inode, struct redirfs_args_t *args, int daemon_is_allowed)
+{
+	struct dazuko_file_struct *dfs = NULL;
+	int error = 0;
+	int check_error = 0;
+	struct event_properties event_p;
+	struct xp_daemon_id xp_id;
+	struct slot_list *sl = NULL;
+
+	dazuko_bzero(&event_p, sizeof(event_p));
+
+	xp_id.pid = current->pid;
+	xp_id.file = NULL;
+	xp_id.current_p = current;
+	xp_id.files = current->files;
+
+	check_error = dazuko_check_access(event, daemon_is_allowed, &xp_id, &sl);
+
+	if (!check_error)
+	{
+		event_p.mode = inode->i_mode;
+		event_p.set_mode = 1;
+		event_p.pid = current->pid;
+		event_p.set_pid = 1;
+		event_p.uid = current->uid;
+		event_p.set_uid = 1;
+
+		dfs = (struct dazuko_file_struct *)xp_malloc(sizeof(struct dazuko_file_struct));
+		if (dfs != NULL)
+		{
+			dazuko_bzero(dfs, sizeof(struct dazuko_file_struct));
+
+			dfs->extra_data = (struct xp_file_struct *)xp_malloc(sizeof(struct xp_file_struct));
+			if (dfs->extra_data != NULL)
+			{
+				dazuko_bzero(dfs->extra_data, sizeof(struct xp_file_struct));
+
+				dfs->filename = dfs->extra_data->full_filename = (char *)args->exts.full_path;
+				dfs->filename_length = dfs->extra_data->full_filename_length = strlen(args->exts.full_path);
+				dfs->extra_data->inode = inode;
+				dfs->file_p.size = inode->i_size;
+				dfs->file_p.set_size = 1;
+				dfs->file_p.uid = inode->i_uid;
+				dfs->file_p.set_uid = 1;
+				dfs->file_p.gid = inode->i_gid;
+				dfs->file_p.set_gid = 1;
+				dfs->file_p.mode = inode->i_mode;
+				dfs->file_p.set_mode = 1;
+				dfs->file_p.device_type = inode->i_rdev;
+				dfs->file_p.set_device_type = 1;
+
+				error = dazuko_process_access(event, dfs, &event_p, sl);
+			}
+			else
+			{
+				xp_free(dfs);
+				dfs = NULL;
+			}
+
+			dazuko_file_struct_cleanup(&dfs);
+		}
+	}
+
+	if (error) {
+		args->retv.rv_int = XP_ERROR_PERMISSION;
+		return REDIRFS_RETV_STOP;
+	}
+
+	return REDIRFS_RETV_CONTINUE;
+
+}
+
+#if defined(ON_EXEC_SUPPORT)
+static enum redirfs_retv dazukoflt_pre_permission(redirfs_context context, struct redirfs_args_t *args)
+{
+	if (!(args->args.i_permission.mode & MAY_EXEC))
+		return REDIRFS_RETV_CONTINUE;
+	
+	/* if full_path is NULL it means that the nameidata structure is NULL
+	 * and  we cannot get the full dentry path */
+	if (!args->exts.full_path)
+		return REDIRFS_RETV_CONTINUE;
+
+	return redirfs_generic(DAZUKO_ON_EXEC, args->args.i_permission.inode, args, 1);
+}
+#endif
+
+#if defined(ON_OPEN_SUPPORT)
+static enum redirfs_retv dazukoflt_pre_open(redirfs_context context, struct redirfs_args_t *args)
+{
+	return redirfs_generic(DAZUKO_ON_OPEN, args->args.f_open.file->f_dentry->d_inode, args, 1);
+}
+#endif
+
+#if defined(ON_CLOSE_SUPPORT) 
+static enum redirfs_retv dazukoflt_post_flush(redirfs_context context, struct redirfs_args_t *args)
+{
+	return redirfs_generic(DAZUKO_ON_CLOSE, args->args.f_flush.file->f_dentry->d_inode, args, 1);
+}
+#endif
+
+#if defined(ON_UNLINK_SUPPORT)
+static enum redirfs_retv dazukoflt_pre_unlink(redirfs_context context, struct redirfs_args_t *args)
+{
+	return redirfs_generic(DAZUKO_ON_UNLINK, args->args.i_unlink.dentry->d_inode, args, 1);
+}
+#endif
+
+#if defined(ON_RMDIR_SUPPORT)
+static enum redirfs_retv dazukoflt_pre_rmdir(redirfs_context context, struct redirfs_args_t *args)
+{
+	return redirfs_generic(DAZUKO_ON_RMDIR, args->args.i_rmdir.dentry->d_inode, args, 1);
+}
+#endif
+
+#endif /* DAZUKO_REDIRFS */
+
 inline int xp_sys_hook()
 {
-#ifndef DAZUKO_FIST
+#if defined(DAZUKO_REDIRFS)
+	char name[] = "dazukoflt";
+	int priority = 666;
+	unsigned long flags = 0;
+	int error = 0;
+#endif
+
+#if !defined(DAZUKO_FIST) && !defined(DAZUKO_REDIRFS)
 #ifndef NO_STACKING_SUPPORT
 	struct security_operations dummy_ops;
 	int got_dummy = 0;
@@ -988,7 +1159,7 @@
 	orig_root = current->fs->root;
 	read_unlock(&current->fs->lock);
 
-#ifndef DAZUKO_FIST
+#if !defined(DAZUKO_FIST) && !defined(DAZUKO_REDIRFS)
 #ifdef NO_STACKING_SUPPORT
 	memset(&dazuko_security_ops, 0, sizeof(dazuko_security_ops));
 	dazuko_security_ops.inode_permission = dazuko_sys_generic;
@@ -1037,6 +1208,31 @@
 #endif
 #endif
 
+#if defined(DAZUKO_REDIRFS)
+	/*
+	 * Registration to the RedirFS Framework
+	 */
+	dazukoflt = redirfs_register_filter(name, priority, flags);
+	if (IS_ERR(dazukoflt)) {
+		xp_print("dazuko: unable to register Dazuko Filter: %d\n", PTR_ERR(dazukoflt));
+		return PTR_ERR(dazukoflt);
+	}
+
+	error = redirfs_set_operations(dazukoflt, dazukoflt_ops);
+	if (error) {
+		redirfs_unregister_filter(dazukoflt);
+		xp_print("dazuko: unable to set Dazuko Filter operations: %d\n", error);
+		return error;
+	}
+
+	error = redirfs_activate_filter(dazukoflt);
+	if (error) {
+		redirfs_unregister_filter(dazukoflt);
+		xp_print("dazuko: unable to activate Dazuko Filter: %d\n", error);
+		return error;
+	}
+#endif
+
 	dev_major = register_chrdev(DAZUKO_DM, DEVICE_NAME, &fops);
 	if (dev_major < 0)
 	{
@@ -1063,6 +1259,9 @@
 
 inline int xp_sys_unhook()
 {
+#if defined(DAZUKO_REDIRFS)
+	int error;
+#endif
 	unregister_chrdev(dev_major, DEVICE_NAME);
 
 	devfs_remove(DEVICE_NAME);
@@ -1075,7 +1274,7 @@
 	class_simple_destroy(dazuko_class);
 #endif
 
-#ifndef DAZUKO_FIST
+#if !defined(DAZUKO_FIST) && !defined(DAZUKO_REDIRFS)
 #ifdef NO_STACKING_SUPPORT
 	if (secondary_register)
 		mod_unreg_security(DEVICE_NAME, &dazuko_security_ops);
@@ -1089,6 +1288,17 @@
 #endif
 #endif
 
+#if defined(DAZUKO_REDIRFS)
+	/*
+	 * Unregistration from the RedirFS Framework
+	 */
+	error = redirfs_unregister_filter(dazukoflt);
+	if (error) {
+		xp_print("dazuko: unable to unregister Dazuko Filter: %d\n", error);
+		return error;
+	}
+#endif
+
 	return 0;
 }
 
