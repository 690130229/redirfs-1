diff -urN dazuko-2.1.0.orig/configure dazuko-2.1.0/configure
--- dazuko-2.1.0.orig/configure	2005-09-08 20:50:40.000000000 +0200
+++ dazuko-2.1.0/configure	2006-02-06 17:08:49.000000000 +0100
@@ -47,6 +47,7 @@
 	echo "override auto-detection values"
 	echo "  --kernelsrcdir=DIR   kernel source files in DIR (Linux only)"
 	echo "  --devicemajor=MAJ    use MAJ for device major number"
+	echo "  --redirfs-path=PATH  PATH to the RedirFS source code (RedirFS interface redirfs.h)"
 	echo "  --system=SYS         configure for system SYS (linux22,linux24,linux26,"
 	echo "                                                freebsd4,freebsd5,dummyos)"
 	echo ""
@@ -63,6 +64,7 @@
 	echo "  --disable-stacking              disable LSM stacking (Linux 2.6 only)"
 	echo "  --disable-local-dpath           disable local __d_path() (Linux 2.6 only)"
 	echo "  --disable-compat1               disable 1.x compatibility (IO/Linux only)"
+	echo "  --enable-redirfs                use RedirFS Framework (for now Linux 2.6 only)"
 	echo "  --enable-debug                  print extra debug information"
 	echo ""
 	echo "optional packages"
@@ -354,64 +356,67 @@
 
 do_linux26()
 {
-	echo -n "checking if security module support is enabled... "
-	if [ $CONFIG_SECURITY -eq 0 ]
+	if [ ${REDIRFS} -eq 0 ]
 	then
-		echo "no"
-		echo "error: security module support must be enabled in your kernel"
-		exit 1
-	else
-		echo "yes"
-	fi
+		echo -n "checking if security module support is enabled... "
+		if [ $CONFIG_SECURITY -eq 0 ]
+		then
+			echo "no"
+			echo "error: security module support must be enabled in your kernel"
+			exit 1
+		else
+			echo "yes"
+		fi
 
-	echo -n "verifying capabilities are not built-in... "
-	if [ $CONFIG_SECURITY_CAPABILITIES -ne 0 ]
-	then
-		echo "built-in :("
-		echo "error: capabilities are built-in to the kernel:"
-		echo "       you will need to recompile a kernel with capabilities"
-		echo "       as a kernel module"
-		exit 1
-	else
-		echo "ok"
-	fi
+		echo -n "verifying capabilities are not built-in... "
+		if [ $CONFIG_SECURITY_CAPABILITIES -ne 0 ]
+		then
+			echo "built-in :("
+			echo "error: capabilities are built-in to the kernel:"
+			echo "       you will need to recompile a kernel with capabilities"
+			echo "       as a kernel module"
+			exit 1
+		else
+			echo "ok"
+		fi
 
-	if [ $CONFIG_SECURITY_CAPABILITIES_MODULE -eq 0 ]
-	then
-		NO_CAPABILITIES=1
-	fi
+		if [ $CONFIG_SECURITY_CAPABILITIES_MODULE -eq 0 ]
+		then
+			NO_CAPABILITIES=1
+		fi
 
-	echo -n "locating LSM API header... "
+		echo -n "locating LSM API header... "
 
-	SRC_PATH_END="/include/linux/security.h"
-	get_src_path
+		SRC_PATH_END="/include/linux/security.h"
+		get_src_path
 
-	if [ ! -f "$SRC_PATH" ]
-	then
-		echo "failed"
-		echo "error: unable to locate security.h"
-		exit 1
-	else
-		echo "ok"
-	fi
+		if [ ! -f "$SRC_PATH" ]
+		then
+			echo "failed"
+			echo "error: unable to locate security.h"
+			exit 1
+		else
+			echo "ok"
+		fi
 
-	echo -n "identifying LSM API... "
-	if [ ! -x "linux_lsm_conf" ]
-	then
-		echo "failed"
-		echo "error: linux_lsm_conf missing in Dazuko distribution"
-		exit 1
-	fi
+		echo -n "identifying LSM API... "
+		if [ ! -x "linux_lsm_conf" ]
+		then
+			echo "failed"
+			echo "error: linux_lsm_conf missing in Dazuko distribution"
+			exit 1
+		fi
 
-	./linux_lsm_conf $SRC_PATH
-	if [ $? -ne 0 ]
-	then
-		echo "failed"
-		echo "error: could not analyze security.h"
-		exit 1
-	fi
+		./linux_lsm_conf $SRC_PATH
+		if [ $? -ne 0 ]
+		then
+			echo "failed"
+			echo "error: could not analyze security.h"
+			exit 1
+		fi
 
-	echo "ok"
+		echo "ok"
+	fi
 
 	echo -n "inspecting suspend function... "
 
@@ -453,22 +458,41 @@
 		echo "ok (class_simple)"
 	fi
 
-	if [ $ON_CLOSE -ne 0 ]
+	echo "configure: creating Makefile"
+
+	echo "EXTRA_CFLAGS += -Wall -DLINUX26_SUPPORT" > Makefile
+
+	if [ ${ON_CLOSE} -ne 0 ]
 	then
-		echo "disabling ON_CLOSE events (not available for Linux 2.6)"
-		ON_CLOSE=0
+		if [ ${REDIRFS} -eq 0 ]
+		then
+			echo "disabling ON_CLOSE events (not available for Linux 2.6)"
+			ON_CLOSE=0
+		else
+			echo "EXTRA_CFLAGS += -DON_CLOSE_SUPPORT" >> Makefile
+		fi
 	fi
 
 	if [ ${ON_UNLINK} -ne 0 ]
 	then
-		echo "disabling ON_UNLINK events (not available for Linux 2.6)"
-		ON_UNLINK=0
+		if [ ${REDIRFS} -eq 0 ]
+		then
+			echo "disabling ON_UNLINK events (not available for Linux 2.6)"
+			ON_UNLINK=0
+		else
+			echo "EXTRA_CFLAGS += -DON_UNLINK_SUPPORT" >> Makefile
+		fi
 	fi
 
 	if [ ${ON_RMDIR} -ne 0 ]
 	then
-		echo "disabling ON_RMDIR events (not available for Linux 2.6)"
-		ON_RMDIR=0
+		if [ ${REDIRFS} -eq 0 ]
+		then
+			echo "disabling ON_RMDIR events (not available for Linux 2.6)"
+			ON_RMDIR=0
+		else
+			echo "EXTRA_CFLAGS += -DON_RMDIR_SUPPORT" >> Makefile
+		fi
 	fi
 
 	if [ ${ON_CLOSE_MODIFIED} -ne 0 ]
@@ -479,11 +503,20 @@
 
 	LINUX26_OBJS="dazuko_linux26.o"
 
-	echo "configure: creating Makefile"
-
-	echo "EXTRA_CFLAGS += -Wall -DLINUX26_SUPPORT" > Makefile
+	if [ ${REDIRFS} -eq 1 ]
+	then
+		if [ -z ${REDIRFS_PATH} ]
+		then
+			echo "error: if you want to use Dazuko with the RedirFS Framework"
+			echo "       you have to specify path to the RedirFS source" 
+			echo "       code with the --redirfs-path option"
+			exit 1
+		fi
+		echo "EXTRA_CFLAGS += -I${REDIRFS_PATH}" >> Makefile
+		echo "EXTRA_CFLAGS += -DDAZUKO_REDIRFS" >> Makefile
+	fi
 
-	if [ ${LSM_STACKING} -eq 1 ]
+	if [ ${LSM_STACKING} -eq 1 -a ${REDIRFS} -eq 0 ]
 	then
 		LINUX26_OBJS="dazuko_linux26_lsm.o ${LINUX26_OBJS}"
 	else
@@ -1014,6 +1047,14 @@
 				echo "no"
 			fi
 
+			echo -n "redirfs support = "
+			if [ ${REDIRFS} -eq 1 ]
+			then
+				echo "yes"
+			else
+				echo "no"
+			fi
+
 			if echo $LINUX_VERSION | grep -q ^2\.6\.
 			then
 				echo -n "stacking support = "
@@ -1096,6 +1137,8 @@
 DEVFS=0
 RSBAC=0
 DEBUG=0
+REDIRFS=0
+REDIRFS_PATH=""
 WITH_MODULE=1
 WITH_LIBRARY=2
 WITH_EXAMPLE_C=1
@@ -1158,6 +1201,12 @@
 		--enable-debug)
 			DEBUG=1
 			;;
+		--enable-redirfs)
+			REDIRFS=1
+			;;
+		--redirfs-path=*)
+			REDIRFS_PATH=`echo $option | sed -e s/^--redirfs-path=//`
+			;;
 		--enable-trusted)
 			TRUSTED=1
 			;;
@@ -1438,24 +1487,38 @@
 			. linux.config
 			rm -f linux.config
 
-			echo -n "checking if Linux is RSBAC patched... "
-			if [ $CONFIG_RSBAC -ne 0 ]
+			if [ $REDIRFS -ne 0 ]
 			then
-				echo "yes"
-				RSBAC=1
-
-				SYSTEM="rsbac"
-			else
-				echo "no"
-
-				echo -n "checking if devfs is enabled... "
-				if [ $CONFIG_DEVFS_FS -eq 0 ]
+				echo -n "checking for redirfs.h... "
+				if [ -f ${REDIRFS_PATH}/redirfs.h ]
 				then
-					DEVFS=0
-					echo "no"
+					echo "yes"
 				else
-					DEVFS=1
+					echo "no"
+					echo "error: file ${REDIRFS_PATH}/redirfs.h not found"
+					echo "       please check the --redirfs-path option"
+					exit 1
+				fi
+			else
+				echo -n "checking if Linux is RSBAC patched... "
+				if [ $CONFIG_RSBAC -ne 0 ]
+				then
 					echo "yes"
+					RSBAC=1
+
+					SYSTEM="rsbac"
+				else
+					echo "no"
+
+					echo -n "checking if devfs is enabled... "
+					if [ $CONFIG_DEVFS_FS -eq 0 ]
+					then
+						DEVFS=0
+						echo "no"
+					else
+						DEVFS=1
+						echo "yes"
+					fi
 				fi
 			fi
 
diff -urN dazuko-2.1.0.orig/dazuko_core.c dazuko-2.1.0/dazuko_core.c
--- dazuko-2.1.0.orig/dazuko_core.c	2005-09-01 20:26:57.000000000 +0200
+++ dazuko-2.1.0/dazuko_core.c	2006-02-08 10:00:32.000000000 +0100
@@ -35,6 +35,9 @@
 #include "dazuko_platform.h"
 #include "dazuko_core.h"
 #include "dazuko_version.h"
+#if defined(DAZUKO_REDIRFS)
+#include "redirfs.h"
+#endif
 
 /* inline code */
 #include "dazuko_call.h"
@@ -58,6 +61,10 @@
 
 #define AMC_UNSET	255
 
+#if defined(DAZUKO_REDIRFS)
+extern redirfs_filter dazukoflt;
+#endif
+
 struct path
 {
 	/* A node in a linked list of paths. Used
@@ -1547,10 +1554,18 @@
 
 		case ADD_INCLUDE_PATH:
 			error = dazuko_insert_path_fs(&(sl->incl_paths), &(sl->lock_lists), (char *)param, len);
+#if defined(DAZUKO_REDIRFS)
+			if (!error)
+				error = redirfs_include_path(dazukoflt, param);
+#endif
 			break;
 
 		case ADD_EXCLUDE_PATH:
 			error = dazuko_insert_path_fs(&(sl->excl_paths), &(sl->lock_lists), (char *)param, len);
+#if defined(DAZUKO_REDIRFS)
+			if (!error)
+				error = redirfs_exclude_path(dazukoflt, param);
+#endif
 			break;
 
 		case REMOVE_ALL_PATHS:
@@ -1882,7 +1897,7 @@
 	int			error;
 
 	i = dazuko_event2index(event);
-	if (i < 0 || i >= NUM_SLOT_LISTS)
+	if (i < 0 || i > NUM_SLOT_LISTS)
 	{
 		call_xp_print("dazuko: unknown event:%d, allowing access (possible bug)\n", event);
 		return 0;
diff -urN dazuko-2.1.0.orig/dazuko_linux26.c dazuko-2.1.0/dazuko_linux26.c
--- dazuko-2.1.0.orig/dazuko_linux26.c	2005-09-03 22:00:35.000000000 +0200
+++ dazuko-2.1.0/dazuko_linux26.c	2006-02-08 09:57:11.000000000 +0100
@@ -35,6 +35,9 @@
 #include <linux/suspend.h>
 #endif
 #include <asm/uaccess.h>
+#if defined(DAZUKO_REDIRFS)
+#include "redirfs.h"
+#endif
 
 
 #ifndef DAZUKO_DM
@@ -62,7 +65,7 @@
 static struct dentry    *orig_root = NULL;
 static int dev_major = -1;
 
-#ifndef DAZUKO_FIST
+#if !defined(DAZUKO_FIST) && !defined(DAZUKO_REDIRFS)
 #ifdef NO_STACKING_SUPPORT
 struct security_operations dazuko_security_ops;
 #else
@@ -81,6 +84,43 @@
 #endif
 #endif
 
+#if defined(DAZUKO_REDIRFS)
+/*
+ *  Global stuffs for the RedirFS Framework
+ */
+redirfs_filter dazukoflt;
+
+#if defined(ON_OPEN_SUPPORT)
+static enum redirfs_retv dazukoflt_pre_permission(redirfs_context context, struct redirfs_args_t *args);
+#endif
+#if defined(ON_CLOSE_SUPPORT) 
+static enum redirfs_retv dazukoflt_post_flush(redirfs_context context, struct redirfs_args_t *args);
+#endif
+#if defined(ON_UNLINK_SUPPORT)
+static enum redirfs_retv dazukoflt_pre_unlink(redirfs_context context, struct redirfs_args_t *args);
+#endif
+#if defined(ON_RMDIR_SUPPORT)
+static enum redirfs_retv dazukoflt_pre_rmdir(redirfs_context context, struct redirfs_args_t *args);
+#endif
+
+static struct redirfs_op_t dazukoflt_ops[] = {
+#if defined(ON_OPEN_SUPPORT)
+	{REDIRFS_I_REG, REDIRFS_IOP_PERMISSION, dazukoflt_pre_permission, NULL},
+#endif
+#if defined(ON_CLOSE_SUPPORT) 
+	{REDIRFS_F_REG, REDIRFS_FOP_FLUSH, NULL, dazukoflt_post_flush},
+#endif
+#if defined(ON_UNLINK_SUPPORT)
+	{REDIRFS_I_DIR, REDIRFS_IOP_UNLINK, dazukoflt_pre_unlink, NULL},
+#endif
+#if defined(ON_RMDIR_SUPPORT)
+	{REDIRFS_I_DIR, REDIRFS_IOP_RMDIR, dazukoflt_pre_rmdir, NULL},
+#endif
+	REDIRFS_OP_END
+};
+#endif
+
+
 #ifdef NO_CAPABILITIES
 int lsm_capability_compare(struct security_operations *ops1, struct security_operations *ops2);
 #endif
@@ -898,9 +938,129 @@
 	return 0;
 }
 
+#if defined(DAZUKO_REDIRFS)
+static int redirfs_generic(int event, struct inode *inode, struct redirfs_args_t *args, int daemon_is_allowed)
+{
+	struct dazuko_file_struct *dfs = NULL;
+	int error = 0;
+	int check_error = 0;
+	struct event_properties event_p;
+	struct xp_daemon_id xp_id;
+	struct slot_list *sl = NULL;
+
+	dazuko_bzero(&event_p, sizeof(event_p));
+
+	xp_id.pid = current->pid;
+	xp_id.file = NULL;
+	xp_id.current_p = current;
+	xp_id.files = current->files;
+
+	check_error = dazuko_check_access(event, daemon_is_allowed, &xp_id, &sl);
+
+	if (!check_error)
+	{
+		event_p.mode = inode->i_mode;
+		event_p.set_mode = 1;
+		event_p.pid = current->pid;
+		event_p.set_pid = 1;
+		event_p.uid = current->uid;
+		event_p.set_uid = 1;
+
+		dfs = (struct dazuko_file_struct *)xp_malloc(sizeof(struct dazuko_file_struct));
+		if (dfs != NULL)
+		{
+			dazuko_bzero(dfs, sizeof(struct dazuko_file_struct));
+
+			dfs->extra_data = (struct xp_file_struct *)xp_malloc(sizeof(struct xp_file_struct));
+			if (dfs->extra_data != NULL)
+			{
+				dazuko_bzero(dfs->extra_data, sizeof(struct xp_file_struct));
+
+				dfs->filename = dfs->extra_data->full_filename = (char *)args->exts.full_path;
+				dfs->filename_length = dfs->extra_data->full_filename_length = strlen(args->exts.full_path);
+				dfs->extra_data->inode = inode;
+				dfs->file_p.size = inode->i_size;
+				dfs->file_p.set_size = 1;
+				dfs->file_p.uid = inode->i_uid;
+				dfs->file_p.set_uid = 1;
+				dfs->file_p.gid = inode->i_gid;
+				dfs->file_p.set_gid = 1;
+				dfs->file_p.mode = inode->i_mode;
+				dfs->file_p.set_mode = 1;
+				dfs->file_p.device_type = inode->i_rdev;
+				dfs->file_p.set_device_type = 1;
+
+				error = dazuko_process_access(event, dfs, &event_p, sl);
+			}
+			else
+			{
+				xp_free(dfs);
+				dfs = NULL;
+			}
+
+			dazuko_file_struct_cleanup(&dfs);
+		}
+	}
+
+	if (error) {
+		args->retv.rv_int = XP_ERROR_PERMISSION;
+		return REDIRFS_RETV_STOP;
+	}
+
+	return REDIRFS_RETV_CONTINUE;
+
+}
+
+#if defined(ON_OPEN_SUPPORT)
+static enum redirfs_retv dazukoflt_pre_permission(redirfs_context context, struct redirfs_args_t *args)
+{
+	int event = DAZUKO_ON_OPEN;
+
+	if (args->args.i_permission.mode & MAY_EXEC)
+		event = DAZUKO_ON_EXEC;
+	
+	/* if full_path is NULL it means that the nameidata structure is NULL
+	 * and  we cannot get the full dentry path */
+	if (!args->exts.full_path)
+		return REDIRFS_RETV_CONTINUE;
+
+	return redirfs_generic(event, args->args.i_permission.inode, args, 1);
+}
+#endif
+
+#if defined(ON_CLOSE_SUPPORT) 
+static enum redirfs_retv dazukoflt_post_flush(redirfs_context context, struct redirfs_args_t *args)
+{
+	return redirfs_generic(DAZUKO_ON_CLOSE, args->args.f_flush.file->f_dentry->d_inode, args, 1);
+}
+#endif
+
+#if defined(ON_UNLINK_SUPPORT)
+static enum redirfs_retv dazukoflt_pre_unlink(redirfs_context context, struct redirfs_args_t *args)
+{
+	return redirfs_generic(DAZUKO_ON_UNLINK, args->args.i_unlink.dentry->d_inode, args, 1);
+}
+#endif
+
+#if defined(ON_RMDIR_SUPPORT)
+static enum redirfs_retv dazukoflt_pre_rmdir(redirfs_context context, struct redirfs_args_t *args)
+{
+	return redirfs_generic(DAZUKO_ON_RMDIR, args->args.i_rmdir.dentry->d_inode, args, 1);
+}
+#endif
+
+#endif /* DAZUKO_REDIRFS */
+
 inline int xp_sys_hook()
 {
-#ifndef DAZUKO_FIST
+#if defined(DAZUKO_REDIRFS)
+	char name[] = "dazukoflt";
+	int priority = 666;
+	unsigned long flags = 0;
+	int error = 0;
+#endif
+
+#if !defined(DAZUKO_FIST) && !defined(DAZUKO_REDIRFS)
 #ifndef NO_STACKING_SUPPORT
 	struct security_operations dummy_ops;
 	int got_dummy = 0;
@@ -944,7 +1104,7 @@
 	orig_root = current->fs->root;
 	read_unlock(&current->fs->lock);
 
-#ifndef DAZUKO_FIST
+#if !defined(DAZUKO_FIST) && !defined(DAZUKO_REDIRFS)
 #ifdef NO_STACKING_SUPPORT
 	memset(&dazuko_security_ops, 0, sizeof(dazuko_security_ops));
 	dazuko_security_ops.inode_permission = dazuko_sys_generic;
@@ -994,6 +1154,23 @@
 #endif
 #endif
 
+#if defined(DAZUKO_REDIRFS)
+	/*
+	 * Registration to the RedirFS Framework
+	 */
+	dazukoflt = redirfs_register_filter(name, priority, flags);
+	if (IS_ERR(dazukoflt))
+		return PTR_ERR(dazukoflt);
+
+	error = redirfs_set_operations(dazukoflt, dazukoflt_ops);
+	if (error) {
+		redirfs_unregister_filter(dazukoflt);
+		return error;
+	}
+
+	redirfs_activate_filter(dazukoflt);
+#endif
+
 	dev_major = register_chrdev(DAZUKO_DM, DEVICE_NAME, &fops);
 	if (dev_major < 0)
 	{
@@ -1028,7 +1205,7 @@
 	class_simple_destroy(dazuko_class);
 #endif
 
-#ifndef DAZUKO_FIST
+#if !defined(DAZUKO_FIST) && !defined(DAZUKO_REDIRFS)
 #ifdef NO_STACKING_SUPPORT
 	if (secondary_register)
 		mod_unreg_security(DEVICE_NAME, &dazuko_security_ops);
@@ -1042,6 +1219,13 @@
 #endif
 #endif
 
+#if defined(DAZUKO_REDIRFS)
+	/*
+	 * Unregistration from the RedirFS Framework
+	 */
+	redirfs_unregister_filter(dazukoflt);
+#endif
+
 	return 0;
 }
 
